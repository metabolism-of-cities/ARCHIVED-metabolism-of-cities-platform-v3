<div id="syncChart" style="width:100%; height: 600px;"></div>

<script>
    $('#syncChart').bind('mousemove touchmove touchstart', function(e) {
      var chart,
        point,
        i,
        event;

      for (i = 0; i < Highcharts.charts.length; i = i + 1) {
        chart = Highcharts.charts[i];

        if (chart && chart.options.chart.isSynced) {
          // Find coordinates within the chart
          event = chart.pointer.normalize(e.originalEvent);
          // Get the hovered point
          point = chart.series[0].searchPoint(event, true);

          if (point) {
            point.highlight(e);
          }
        }
      }
    });

    /**
     * Override the reset function, we don't need to hide the tooltips and
     * crosshairs.
     */
    Highcharts.Pointer.prototype.reset = function() {
      return undefined;
    };

    /**
     * Highlight a point by showing tooltip, setting hover state and draw crosshair
     */
    Highcharts.Point.prototype.highlight = function(event) {
      event = this.series.chart.pointer.normalize(event);
      this.onMouseOver(); // Show the hover marker
      this.series.chart.tooltip.refresh(this); // Show the tooltip
      this.series.chart.xAxis[0].drawCrosshair(event, this); // Show the crosshair
    };

    /**
     * Synchronize zooming through the setExtremes event handler.
     */
    function syncExtremes(e) {
      var thisChart = this.chart;

      if (e.trigger !== 'syncExtremes') { // Prevent feedback loop
        Highcharts.each(Highcharts.charts, function(chart) {
          if (chart !== thisChart) {
            if (chart.xAxis[0].setExtremes) { // It is null while updating
              chart.xAxis[0].setExtremes(
                e.min,
                e.max,
                undefined,
                false, {
                  trigger: 'syncExtremes'
                }
              );
            }
          }
        });
      }
    }

    syncData = {
      "xData": [1328976393245, 1428976393245, 1528976393245],
      "datasets": barColumnSeries
    }

    $.getJSON(
      'https://cdn.rawgit.com/highcharts/highcharts/v6.0.4/samples/data/activity.json',
      function(activity) {
        $.each(activity.datasets, function(i, dataset) {

          // Add X values
          dataset.data = Highcharts.map(dataset.data, function(val, j) {
            return [activity.xData[j], val];
          });

          var syncChartDiv = document.createElement('div');
          syncChartDiv.className = 'chart';
          document.getElementById('syncChart').appendChild(syncChartDiv);

          console.log(activity.datasets.length);

          Highcharts.chart(syncChartDiv, {
              chart: {
                isSynced: true,
                height: 600 / activity.datasets.length,
                marginLeft: 40, // Keep all charts left aligned
                spacingTop: 20,
                spacingBottom: 20
              },
              title: {
                text: dataset.name,
                align: 'left',
                margin: 0,
                x: 30
              },
              legend: {
                enabled: false
              },

              xAxis: {
                visible: false,
                crosshair: true,
                events: {
                  setExtremes: syncExtremes
                },
                labels: {
                  format: '{value} km'
                }
              },
              yAxis: {
                visible: false,
                title: {
                  text: null
                }
              },
              tooltip: {
                positioner: function() {
                  return {
                    // right aligned
                    x: this.chart.chartWidth - this.label.width - 40,
                    y: 10 // align to title
                  };
                },
                borderWidth: 0,
                backgroundColor: 'none',
                pointFormat: '{point.y}',
                headerFormat: '',
                shadow: false,
                style: {
                  fontSize: '14px'
                },
                valueDecimals: dataset.valueDecimals
              },
              series: [{
                data: dataset.data,
                name: dataset.name,
                type: dataset.type,
                color: colorScheme[i],
                fillOpacity: 0.3,
                tooltip: {
                  valueSuffix: ' ' + dataset.unit
                }
              }]

            });
        });
        // lines for chart burger menu thinner
        $(".highcharts-button-symbol").attr("stroke-width", 1);
      }
    );
</script>

<!-- <script>
    $('#syncChart').bind('mousemove touchmove touchstart', function(e) {
      var chart,
        point,
        i,
        event;

      for (i = 0; i < Highcharts.charts.length; i = i + 1) {
        chart = Highcharts.charts[i];

        if (chart && chart.options.chart.isSynced) {
          // Find coordinates within the chart
          event = chart.pointer.normalize(e.originalEvent);
          // Get the hovered point
          point = chart.series[0].searchPoint(event, true);

          if (point) {
            point.highlight(e);
          }
        }
      }
    });
    /**
     * Override the reset function, we don't need to hide the tooltips and
     * crosshairs.
     */
    Highcharts.Pointer.prototype.reset = function() {
      return undefined;
    };

    /**
     * Highlight a point by showing tooltip, setting hover state and draw crosshair
     */
    Highcharts.Point.prototype.highlight = function(event) {
      event = this.series.chart.pointer.normalize(event);
      this.onMouseOver(); // Show the hover marker
      this.series.chart.tooltip.refresh(this); // Show the tooltip
      this.series.chart.xAxis[0].drawCrosshair(event, this); // Show the crosshair
    };

    /**
     * Synchronize zooming through the setExtremes event handler.
     */
    function syncExtremes(e) {
      var thisChart = this.chart;

      if (e.trigger !== 'syncExtremes') { // Prevent feedback loop
        Highcharts.each(Highcharts.charts, function(chart) {
          if (chart !== thisChart) {
            if (chart.xAxis[0].setExtremes) { // It is null while updating
              chart.xAxis[0].setExtremes(
                e.min,
                e.max,
                undefined,
                false, {
                  trigger: 'syncExtremes'
                }
              );
            }
          }
        });
      }
    }


    syncData = {
      "xData": [1328976393245, 1428976393245, 1528976393245],
      "datasets": barColumnSeries
    }

    syncData.datasets.forEach(function (dataset, i) {

        // Add X values
        dataset.data = Highcharts.map(dataset.data, function (val, j) {
            return [syncData.xData[j], val];
        });

        var syncChartDiv = document.createElement('div');
        syncChartDiv.className = 'chart';
        document.getElementById('syncChart').appendChild(syncChartDiv);



        Highcharts.chart(syncChartDiv, {
            chart: {
                marginLeft: 40, // Keep all charts left aligned
                spacingTop: 20,
                spacingBottom: 20
            },
            title: {
                text: dataset.name,
                align: 'middle',
                margin: 0,
                x: 30
            },
            legend: {
                enabled: false
            },
            xAxis: {
              type: 'datetime',
              crosshair: true,
                events: {
                    setExtremes: syncExtremes
                },
              dateTimeLabelFormats: {
                  month: '%B %Y',
                  year: '%B %Y'
              },
            },
            yAxis: {
                title: {
                    text: null
                }
            },
            tooltip: {
                positioner: function () {
                    return {
                        // right aligned
                        x: this.chart.chartWidth - this.label.width - 40,
                        y: 10 // align to title
                    };
                },
                borderWidth: 0,
                backgroundColor: 'none',
                pointFormat: '{point.y}',
                headerFormat: '',
                shadow: false,
                style: {
                    fontSize: '18px'
                },
                valueDecimals: dataset.valueDecimals
            },
            series: [{
                data: dataset.data,
                name: dataset.name,
                type: dataset.type,
                color: colorScheme[i],
                fillOpacity: 0.3,
                tooltip: {
                  valueSuffix: ' ' + dataset.unit
                }
            }]
        });
    });

</script>
 -->